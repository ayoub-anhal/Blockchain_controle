# TP Blockchain – Guide du Notebook Professionnel

Ce dépôt contient un notebook Jupyter professionnel (`TP_controle.ipynb`) dédié à la conception, à l'implémentation et à l'analyse d'une mini-blockchain pédagogique. Le notebook mêle théorie, code Python proprement commenté et démonstrations contrôlées afin d'offrir une progression académique complète : des fondations conceptuelles jusqu'aux scénarios de décentralisation simulée.

## Table des matières
1. [Organisation académique](#organisation-académique)
   1. [Objectifs pédagogiques](#objectifs-pédagogiques)
   2. [Hypothèses et cadre d'étude](#hypothèses-et-cadre-détude)
   3. [Limites du prototype](#limites-du-prototype)
   4. [Progression du notebook](#progression-du-notebook)
2. [Structure du code et bonnes pratiques](#structure-du-code-et-bonnes-pratiques)
3. [Démonstrations contrôlées](#démonstrations-contrôlées)
4. [API REST simulée](#api-rest-simulée)
5. [Fonctions d'analytics](#fonctions-danalytics)
6. [Simulation de décentralisation](#simulation-de-décentralisation)
7. [Références essentielles](#références-essentielles)

## Organisation académique

### Objectifs pédagogiques
- Comprendre l'anatomie d'un bloc et les mécanismes fondamentaux d'une blockchain (chaînage des hachages, preuve de travail, validation).
- Construire pas à pas une implémentation Python fortement typée et réutilisable de la blockchain étudiée.
- Explorer une API REST simulée pour interagir avec la chaîne (lecture, transactions, minage, analyse de balances).
- Étudier la décentralisation par la simulation de plusieurs nœuds, de la diffusion naïve et de la résolution de conflits.

### Hypothèses et cadre d'étude
- Les participants maîtrisent les bases de Python (classes, dataclasses, annotations de type) et de la programmation orientée objet.
- Le réseau est simulé localement : aucune communication réelle sur le réseau n'est réalisée, ce qui facilite la reproductibilité et l'analyse.
- Les transactions sont simplifiées (pas de signatures cryptographiques) afin de se concentrer sur le mécanisme de consensus et le flux des blocs.

### Limites du prototype
- Le temps de minage est volontairement borné par une difficulté faible (2 à 3 zéros initiaux) pour garantir des exécutions rapides et éviter toute attente excessive.
- Les problématiques de sécurité avancées (attaques Sybil, 51 %, coûts économiques) sont évoquées mais non implémentées.
- L'API REST simulée n'est pas exposée via un serveur réel ; elle sert d'outil pédagogique pour illustrer les appels et les réponses JSON canoniques.

### Progression du notebook
1. **Théorie** – Introduction conceptuelle à la blockchain, principes fondamentaux, vocabulaire, diagrammes ASCII illustratifs.
2. **Implémentation** – Construction progressive de la classe `Block`, de la chaîne (`Blockchain`), puis ajout des transactions et du minage via des fonctions utilitaires.
3. **Démonstration** – Exécution de scénarios commentés avec métriques de minage, bilans des comptes, journaux d'événements.
4. **Analyse** – Interprétation des résultats, mise en évidence des limites, propositions d'améliorations.

Cette structure est répétée à chaque section majeure pour ancrer les connaissances (théorie → code → démo → analyse).

## Structure du code et bonnes pratiques

Le notebook est conçu comme un support professionnel où chaque cellule de code est accompagnée de commentaires et de docstrings. Les choix techniques principaux sont :

- **Dataclasses** pour modéliser les entités (`Block`, `Transaction`, `Node`) avec sérialisation JSON canonique (`json.dumps(..., sort_keys=True)`).
- **Annotations de type** systématiques et fonctions utilitaires dédiées (`hash_block`, `load_chain_from_json`, `compute_balance`).
- **Organisation modulaire** par sections : bloc de configuration initiale, classes principales, utilitaires d'analytics, API pédagogique.
- **Docstrings normalisées** (format reStructuredText) pour chaque fonction exposée afin de faciliter l'autocomplétion et la génération de documentation.
- **Gestion des timestamps** avec le format RFC 3339 pour garantir l'interopérabilité et la clarté des journaux d'événements.

## Démonstrations contrôlées

Toutes les démonstrations reposent sur un minage à difficulté 2 ou 3 pour garantir des temps d'exécution inférieurs à quelques secondes. Chaque scénario consigne :

- Le nombre moyen d'itérations nécessaires pour trouver un nonce valide.
- Le hash obtenu et son respect de la difficulté imposée.
- Les transactions minées et la récompense associée.
- Une analyse qualitative des résultats (impact sur les balances, sécurité du réseau).

## API REST simulée

Une API pédagogique est définie pour illustrer la manière dont une blockchain s'ouvre sur l'extérieur. Les endpoints sont décrits dans le notebook avec exemples d'appels et de réponses JSON :

| Méthode | Endpoint           | Description                                                    |
|---------|--------------------|----------------------------------------------------------------|
| `GET`   | `/get_chain`       | Récupère l'état complet de la blockchain (liste de blocs).     |
| `POST`  | `/add_transaction` | Ajoute une transaction validée dans la file d'attente.         |
| `GET`   | `/mine_block`      | Lance le minage d'un nouveau bloc avec les transactions en attente. |
| `GET`   | `/get_balance`     | Calcule la balance d'une adresse à partir de la chaîne valide. |

Chaque réponse suit un format JSON canonique, avec champs horodatés en RFC 3339 et codes d'état simulés pour faciliter le débogage.

## Fonctions d'analytics

Le notebook intègre un module d'analytics pour mesurer la vitalité de la chaîne :

- Nombre total de transactions et volume agrégé.
- Liste des adresses actives et leur fréquence d'apparition.
- Itérations moyennes de minage par bloc et temps moyen associé.
- Rapport synthétique généré en Markdown, prêt à être exporté.

Ces indicateurs permettent d'entamer une réflexion sur les performances et la résilience du protocole implémenté.

## Simulation de décentralisation

La deuxième partie du notebook met en scène plusieurs nœuds simulés, chacun conservant sa propre copie de la blockchain et communiquant via des méthodes Python :

- **Gestion des pairs** : enregistrement, synchronisation initiale, diffusion naïve des nouveaux blocs.
- **Résolution de conflits** : adoption de la chaîne la plus longue et vote simplifié lorsque deux chaînes valides de même longueur coexistent.
- **Scénarios avancés** : partition réseau, bloc malveillant rejeté, tentative de double dépense et discussion sur les protections nécessaires.
- **Tableaux d'analyse** : état de santé du réseau, taux de propagation, fréquence des forks, taux de consensus.

Ces démonstrations soulignent les défis de la décentralisation et les compromis inhérents aux protocoles de consensus.

## Références essentielles 

- Satoshi Nakamoto. *Bitcoin: A Peer-to-Peer Electronic Cash System*. [bitcoin.org](https://bitcoin.org/bitcoin.pdf)
- Andreas M. Antonopoulos & Olaoluwa Osuntokun Harding. *Mastering Bitcoin*. [GitHub](https://github.com/bitcoinbook/bitcoinbook)
- NIST. *FIPS 180-4 Secure Hash Standard (SHA-256)*. [NIST CSRC](https://csrc.nist.gov/publications/detail/fips/180/4/final)
- *RFC 3339: Date and Time on the Internet*. [rfc-editor.org](https://www.rfc-editor.org/rfc/rfc3339)
- Juan A. Garay, Aggelos Kiayias, Nikos Leonardos. *The Bitcoin Backbone Protocol: Analysis and Applications*. [SpringerLink](https://link.springer.com/chapter/10.1007/978-3-662-46803-6_10)
- Documentation FastAPI. [fastapi.tiangolo.com](https://fastapi.tiangolo.com/)
- Documentation Flask. [flask.palletsprojects.com](https://flask.palletsprojects.com/)
- (Optionnel) Princeton University. *Bitcoin and Cryptocurrency Technologies*. [collaborate.princeton.edu](https://collaborate.princeton.edu/en/public-offering/bitcoin-and-cryptocurrency-technologies)

---

Pour exécuter le notebook, ouvrez `TP_controle.ipynb` dans un environnement Jupyter Lab ou VS Code compatible. Chaque section contient des instructions spécifiques pour reproduire les expériences et interpréter les résultats.